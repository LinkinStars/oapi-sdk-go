// Package vc code generated by lark suite oapi sdk gen
package vc

import (
	"context"
	"net/http"

	"github.com/larksuite/oapi-sdk-go/v2"
)

type VcService struct {
	Meetings         *meetings
	MeetingRecording *meetingRecording
	Reports          *reports
	Reserves         *reserves
	RoomConfigs      *roomConfigs
}

func New(app *lark.App) *VcService {
	v := &VcService{}
	v.Meetings = &meetings{app: app}
	v.MeetingRecording = &meetingRecording{app: app}
	v.Reports = &reports{app: app}
	v.Reserves = &reserves{app: app}
	v.RoomConfigs = &roomConfigs{app: app}
	return v
}

type meetings struct {
	app *lark.App
}
type meetingRecording struct {
	app *lark.App
}
type reports struct {
	app *lark.App
}
type reserves struct {
	app *lark.App
}
type roomConfigs struct {
	app *lark.App
}

func (m *meetings) Invite(ctx context.Context, req *MeetingInviteReq, options ...lark.RequestOptionFunc) (*MeetingInviteResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/invite", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingInviteResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetings) SetHost(ctx context.Context, req *MeetingSetHostReq, options ...lark.RequestOptionFunc) (*MeetingSetHostResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/set_host", []lark.AccessTokenType{lark.AccessTokenTypeUser, lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingSetHostResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetings) End(ctx context.Context, req *MeetingEndReq, options ...lark.RequestOptionFunc) (*MeetingEndResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/end", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingEndResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetings) Get(ctx context.Context, req *MeetingGetReq, options ...lark.RequestOptionFunc) (*MeetingGetResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/meetings/:meeting_id", []lark.AccessTokenType{lark.AccessTokenTypeUser, lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingGetResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetings) Kickout(ctx context.Context, req *MeetingKickoutReq, options ...lark.RequestOptionFunc) (*MeetingKickoutResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPost,
		"/open-apis/vc/v1/meetings/:meeting_id/kickout", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingKickoutResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetings) ListByNo(ctx context.Context, req *MeetingListByNoReq, options ...lark.RequestOptionFunc) (*MeetingListByNoResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/meetings/list_by_no", []lark.AccessTokenType{lark.AccessTokenTypeUser, lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingListByNoResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetingRecording) Get(ctx context.Context, req *MeetingRecordingGetReq, options ...lark.RequestOptionFunc) (*MeetingRecordingGetResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/meetings/:meeting_id/recording", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingRecordingGetResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetingRecording) Stop(ctx context.Context, req *MeetingRecordingStopReq, options ...lark.RequestOptionFunc) (*MeetingRecordingStopResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/recording/stop", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingRecordingStopResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetingRecording) SetPermission(ctx context.Context, req *MeetingRecordingSetPermissionReq, options ...lark.RequestOptionFunc) (*MeetingRecordingSetPermissionResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/recording/set_permission", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingRecordingSetPermissionResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (m *meetingRecording) Start(ctx context.Context, req *MeetingRecordingStartReq, options ...lark.RequestOptionFunc) (*MeetingRecordingStartResp, error) {
	rawResp, err := m.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/vc/v1/meetings/:meeting_id/recording/start", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &MeetingRecordingStartResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reports) GetTopUser(ctx context.Context, req *ReportGetTopUserReq, options ...lark.RequestOptionFunc) (*ReportGetTopUserResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/reports/get_top_user", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReportGetTopUserResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reports) GetDaily(ctx context.Context, req *ReportGetDailyReq, options ...lark.RequestOptionFunc) (*ReportGetDailyResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/reports/get_daily", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReportGetDailyResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reserves) Update(ctx context.Context, req *ReserveUpdateReq, options ...lark.RequestOptionFunc) (*ReserveUpdateResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPut,
		"/open-apis/vc/v1/reserves/:reserve_id", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReserveUpdateResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reserves) Apply(ctx context.Context, req *ReserveApplyReq, options ...lark.RequestOptionFunc) (*ReserveApplyResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPost,
		"/open-apis/vc/v1/reserves/apply", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReserveApplyResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reserves) Get(ctx context.Context, req *ReserveGetReq, options ...lark.RequestOptionFunc) (*ReserveGetResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/reserves/:reserve_id", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReserveGetResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reserves) GetActiveMeeting(ctx context.Context, req *ReserveGetActiveMeetingReq, options ...lark.RequestOptionFunc) (*ReserveGetActiveMeetingResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/reserves/:reserve_id/get_active_meeting", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReserveGetActiveMeetingResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *reserves) Delete(ctx context.Context, req *ReserveDeleteReq, options ...lark.RequestOptionFunc) (*ReserveDeleteResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodDelete,
		"/open-apis/vc/v1/reserves/:reserve_id", []lark.AccessTokenType{lark.AccessTokenTypeUser}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &ReserveDeleteResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *roomConfigs) Query(ctx context.Context, req *RoomConfigQueryReq, options ...lark.RequestOptionFunc) (*RoomConfigQueryResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/vc/v1/room_configs/query", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &RoomConfigQueryResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (r *roomConfigs) Set(ctx context.Context, req *RoomConfigSetReq, options ...lark.RequestOptionFunc) (*RoomConfigSetResp, error) {
	rawResp, err := r.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPost,
		"/open-apis/vc/v1/room_configs/set", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &RoomConfigSetResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
