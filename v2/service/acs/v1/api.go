// Package acs code generated by lark suite oapi sdk gen
package acs

import (
	"bytes"
	"context"
	"net/http"

	"github.com/larksuite/oapi-sdk-go/v2"
)

type AcsService struct {
	AccessRecords           *accessRecords
	Users                   *users
	AccessRecordAccessPhoto *accessRecordAccessPhoto
	Devices                 *devices
	UserFace                *userFace
}

func New(app *lark.App) *AcsService {
	a := &AcsService{}
	a.AccessRecords = &accessRecords{app: app}
	a.Users = &users{app: app}
	a.AccessRecordAccessPhoto = &accessRecordAccessPhoto{app: app}
	a.Devices = &devices{app: app}
	a.UserFace = &userFace{app: app}
	return a
}

type accessRecords struct {
	app *lark.App
}
type users struct {
	app *lark.App
}
type accessRecordAccessPhoto struct {
	app *lark.App
}
type devices struct {
	app *lark.App
}
type userFace struct {
	app *lark.App
}

func (a *accessRecords) List(ctx context.Context, req *AccessRecordListReq, options ...lark.RequestOptionFunc) (*AccessRecordListResp, error) {
	rawResp, err := a.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/access_records", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &AccessRecordListResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (a *accessRecordAccessPhoto) Get(ctx context.Context, req *AccessRecordAccessPhotoGetReq, options ...lark.RequestOptionFunc) (*AccessRecordAccessPhotoGetResp, error) {
	options = append(options, lark.WithFileDownload())
	rawResp, err := a.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/access_records/:access_record_id/access_photo", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &AccessRecordAccessPhotoGetResp{RawResponse: rawResp}
	if rawResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(rawResp.RawBody)
		resp.FileName = lark.FileNameByHeader(rawResp.Header)
		return resp, err
	}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (d *devices) List(ctx context.Context, options ...lark.RequestOptionFunc) (*DeviceListResp, error) {
	rawResp, err := d.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/devices", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, nil, options...)
	if err != nil {
		return nil, err
	}
	resp := &DeviceListResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (u *users) Patch(ctx context.Context, req *UserPatchReq, options ...lark.RequestOptionFunc) (*UserPatchResp, error) {
	rawResp, err := u.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPatch,
		"/open-apis/acs/v1/users/:user_id", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &UserPatchResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (u *users) Get(ctx context.Context, req *UserGetReq, options ...lark.RequestOptionFunc) (*UserGetResp, error) {
	rawResp, err := u.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/users/:user_id", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &UserGetResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (u *users) List(ctx context.Context, req *UserListReq, options ...lark.RequestOptionFunc) (*UserListResp, error) {
	rawResp, err := u.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/users", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &UserListResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (u *userFace) Get(ctx context.Context, req *UserFaceGetReq, options ...lark.RequestOptionFunc) (*UserFaceGetResp, error) {
	options = append(options, lark.WithFileDownload())
	rawResp, err := u.app.SendRequestWithAccessTokenTypes(ctx, http.MethodGet,
		"/open-apis/acs/v1/users/:user_id/face", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &UserFaceGetResp{RawResponse: rawResp}
	if rawResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(rawResp.RawBody)
		resp.FileName = lark.FileNameByHeader(rawResp.Header)
		return resp, err
	}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (u *userFace) Update(ctx context.Context, req *UserFaceUpdateReq, options ...lark.RequestOptionFunc) (*UserFaceUpdateResp, error) {
	options = append(options, lark.WithFileUpload())
	rawResp, err := u.app.SendRequestWithAccessTokenTypes(ctx, http.MethodPut,
		"/open-apis/acs/v1/users/:user_id/face", []lark.AccessTokenType{lark.AccessTokenTypeTenant}, req, options...)
	if err != nil {
		return nil, err
	}
	resp := &UserFaceUpdateResp{RawResponse: rawResp}
	err = rawResp.JSONUnmarshalBody(resp)
	if err != nil {
		return nil, err
	}
	return resp, err
}
